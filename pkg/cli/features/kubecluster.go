package features

import (
	"bufio"
	"os"
	"slices"
	"strconv"
	"strings"

	"github.com/gravitational/trace"
	"github.com/solidDoWant/backup-tool/pkg/kubecluster"
	"github.com/solidDoWant/backup-tool/pkg/kubecluster/primatives/approverpolicy"
	"github.com/solidDoWant/backup-tool/pkg/kubecluster/primatives/certmanager"
	"github.com/solidDoWant/backup-tool/pkg/kubecluster/primatives/cnpg"
	"github.com/solidDoWant/backup-tool/pkg/kubecluster/primatives/core"
	"github.com/solidDoWant/backup-tool/pkg/kubecluster/primatives/externalsnapshotter"
	"github.com/spf13/cobra"
)

const (
	defaultKubeLabelsFilePath = "/etc/backup-tool/labels"
)

var defaultEnabledLabels = []string{"app.kubernetes.io/name", "app.kubernetes.io/instance"}

type KubeClusterCommandInterface interface {
	KubernetesCommandInterface
	NewKubeClusterClient() (kubecluster.ClientInterface, error)
}

// Gives a command the ability to interact with Kubernetes clusters (all supported APIs).
type KubeClusterCommand struct {
	KubernetesCommand
	labelsFilePath string
	enabledLabels  []string
}

func NewKubeClusterCommand() *KubeClusterCommand {
	return &KubeClusterCommand{}
}

func (kcc *KubeClusterCommand) ConfigureFlags(cmd *cobra.Command) {
	kcc.KubernetesCommand.ConfigureFlags(cmd)
	cmd.Flags().StringVar(&kcc.labelsFilePath, "kube-labels-file", defaultKubeLabelsFilePath, "Path to a file containing labels to apply to resources created by the command.")
	// Useful for filtering out labels generated by downwardAPI volumes on job pods. If the propegated labels matches the selector on the job,
	// created pods will be immediately deleted and the job will inevidably fail.
	cmd.Flags().StringSliceVar(&kcc.enabledLabels, "kube-label-names", defaultEnabledLabels, "List of the names of labels that can be applied to resources created by the command.")
}

// Parse the labels file and return the labels as a map.
// file should have a single key/quoted value pair on each line, separated by an '=' character.
// This is usually generated by a downwardAPI volume mount.
// Example:
// key1="value1"
// key2="value2"
// key3="value3"
// ...
func (kcc *KubeClusterCommand) getLabels() (map[string]string, error) {
	if kcc.labelsFilePath == "" {
		return nil, nil
	}

	if _, err := os.Stat(kcc.labelsFilePath); os.IsNotExist(err) {
		return nil, nil
	} else if err != nil {
		return nil, trace.Wrap(err, "failed to check if labels file exists")
	}

	labelsFile, err := os.Open(kcc.labelsFilePath)
	if err != nil {
		return nil, trace.Wrap(err, "failed to open labels file")
	}
	defer labelsFile.Close()

	// Read file line by line, and split each line by the first '=' character.
	// The first part is the key, and the second part is the value.
	labels := make(map[string]string)
	scanner := bufio.NewScanner(labelsFile)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		key, value, foundSeparator := strings.Cut(line, "=")
		if !foundSeparator {
			return nil, trace.BadParameter("line %q missing '=' separator character: %q", kcc.labelsFilePath, line)
		}

		if !slices.Contains(kcc.enabledLabels, key) {
			continue
		}

		labels[key], err = strconv.Unquote(value)
		if err != nil {
			return nil, trace.Wrap(err, "failed to unquote value %q for key %q in file %q", value, key, kcc.labelsFilePath)
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, trace.Wrap(err, "failed to read labels file %q", kcc.labelsFilePath)
	}

	return labels, nil
}

func (kcc *KubeClusterCommand) NewKubeClusterClient() (kubecluster.ClientInterface, error) {
	config, err := kcc.GetClusterConfig()
	if err != nil {
		return nil, trace.Wrap(err, "failed to get kubernetes config")
	}

	commonLabels, err := kcc.getLabels()
	if err != nil {
		return nil, trace.Wrap(err, "failed to get common labels")
	}

	cmClient, err := certmanager.NewClient(config)
	if err != nil {
		return nil, trace.Wrap(err, "failed to create cert-manager client")
	}

	cnpgClient, err := cnpg.NewClient(config)
	if err != nil {
		return nil, trace.Wrap(err, "failed to create cloudnative-pg client")
	}
	cnpgClient.SetCommonLabels(commonLabels)

	esClient, err := externalsnapshotter.NewClient(config)
	if err != nil {
		return nil, trace.Wrap(err, "failed to create external-snapshotter client")
	}

	coreClient, err := core.NewClient(config)
	if err != nil {
		return nil, trace.Wrap(err, "failed to create core client")
	}
	coreClient.SetCommonLabels(commonLabels)

	apClient, err := approverpolicy.NewClient(config)
	if err != nil {
		return nil, trace.Wrap(err, "failed to create approver-policy client")
	}

	return kubecluster.NewClient(
		cmClient,
		cnpgClient,
		esClient,
		coreClient,
		apClient,
	), nil
}
